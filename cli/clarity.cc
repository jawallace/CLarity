//! @file       clarity-cli.cc
//! @brief      Command Line Interface for clarity library
//!
//! @author     Jeffrey Wallace
//! @copyright  MIT

// CLarity Imports
#include "camera.h"
#include "buffer.h"
#include "cl_range_calculator.h"
#include "cpu_range_calculator.h"
#include "diamond_square_terrain_generator.h"
#include "device_buffer.h"
#include "range_calculator.h"
#include "terrain.h"

// Standard Imports
#include <cmath>
#include <chrono>
#include <memory>
#include <fstream>
#include <iostream>
#include <string>
#include <sys/stat.h>

// Third-Party Imports
#include "cl.hpp"


namespace clarity {
namespace cli {

enum Tool {
  HELP = 0,
  TERRAIN_GENERATOR = 1,
  RANGE_MAPPER
};


void general_usage()
{
  std::cerr << "clarity-cli - Command Line Interface to the CLarity project" << std::endl;
  std::cerr << "Usage: " << std::endl;
  std::cerr << "clarity-cli <tool> [ <tool args> ]" << std::endl;
  std::cerr << "\tAvailable tools: " << std::endl;
  std::cerr << "\t\tterrain - generate a terrain map file" << std::endl;
  std::cerr << "\t\trange - calculate a range mapping" << std::endl;
  std::cerr << "\tRun clarity-cli help <tool name> for more information" << std::endl;
}


Tool get_tool_name(int argc, char ** argv)
{
  if (argc < 2) {
    std::cerr << "Invalid arguments. Please specify a tool" << std::endl;
    general_usage();
    exit(EXIT_FAILURE);
  }


  std::string toolname(argv[1]);

  if (toolname == "help") {
    return Tool::HELP;
  } else if (toolname == "terrain") {
    return Tool::TERRAIN_GENERATOR;
  } else if (toolname == "range") {
    return Tool::RANGE_MAPPER;
  }

  return Tool::HELP;
}


void terrain_tool_usage()
{
  std::cerr << "CLarity Terrain Generator - generates a random scene of terrain" << std::endl;
  std::cerr << "Usage: " << std::endl;
  std::cerr << "clarity-cli terrain <scale> <detail> <roughness> <output>" << std::endl;
  std::cerr << "\t<scale> - the scale of the terrain map, in meters per pixel." << std::endl;
  std::cerr << "\t<detail> - the detail level of the the terrain. Valid in the range [1, 5]" << std::endl;
  std::cerr << "\t<roughness> - the roughness of the terrain. Valid in the range [1, 100]" << std::endl;
  std::cerr << "\t<output> - complete path to an output file where the map will be stored" << std::endl;
}


struct Terrain_Args
{
  float scale;
  int detail;
  int roughness;
  std::string output;
};


Terrain_Args parse_terrain_tool_args(int argc, char ** argv)
{
  if (argc < 4) {
    std::cerr << "Invalid arguments. The Terrain tool has 4 required arguments" << std::endl;
    terrain_tool_usage();
    exit(EXIT_FAILURE);
  }

  Terrain_Args args;
  args.scale = std::stof(std::string(argv[0]));
  args.detail = std::stoi(std::string(argv[1]));
  args.roughness = std::stoi(std::string(argv[2]));
  args.output = std::string(argv[3]);

  if (args.detail < 1 || args.detail > 5) {
    std::cerr << "Invalid arguments. Detail must be between [1, 5]" << std::endl;
    terrain_tool_usage();
    exit(EXIT_FAILURE);
  }

  // shift into proper range
  args.detail = args.detail + 7;

  if (args.roughness < 1 || args.roughness > 100) {
    std::cerr << "Invalid arguments. Roughness must be between [1, 100]" << std::endl;
    terrain_tool_usage();
    exit(EXIT_FAILURE);
  }

  return args;
}


void run_terrain_tool(int argc, char ** argv)
{
  Terrain_Args args = parse_terrain_tool_args(argc, argv);

  const uint32_t size = std::pow(2, args.detail) + 1;
  std::shared_ptr<Buffer> buffer = std::make_shared<Buffer>(size, size);

  Diamond_Square_Generator generator;
  Terrain t = generator.generate_terrain(buffer, args.scale, args.roughness);

  std::ofstream out(args.output, std::ios::out | std::ios::binary);
  out.write(reinterpret_cast<const char *>(&size), 4); // dimension of terrain - 4 bytes, uint32_t
  out.write(reinterpret_cast<char *>(&args.scale), 4); // scale of terrain - 4 bytes, float

  out.write(reinterpret_cast<char *>(buffer->data().get()), size * size * sizeof(float)); // terrain data

  std::cout << "Wrote terrain file to " << args.output << std::endl;
  const float sz_m = size * args.scale;
  std::cout << "Valid locations for this terrain: (0.0, " << sz_m << ") m in x-dimension,  (0.0, " << sz_m << ") m in y-dimension" << std::endl;
}


void range_tool_usage()
{
  std::cerr << "CLarity Range Image Generator - creates range map based on terrain and position" << std::endl;
  std::cerr << "Usage: " << std::endl;
  std::cerr << "clarity-cli range <mode> <terrain_file> <cam fov> <cam dim> <cam_posn> <cam_yaw> <cam_roll> <output>" << std::endl;
  std::cerr << "\tmode - should we run on the CPU (naive) or use OpenCL? Valid modes: (CPU, OpenCL)" << std::endl;
  std::cerr << "\tterrain_file - terrain to use. Should be file generated by terrain tool" << std::endl;
  std::cerr << "\tcamera fov - field of view of the camera, in degrees (90 is typical)" << std::endl;
  std::cerr << "\tcamera dim - dimensions of the camera's focal plane array. One value (256 is typical)" << std::endl;
  std::cerr << "\tcamera posn - position of the camera in the scene, in meters. Three floating point values." << std::endl;
  std::cerr << "\tcamera yaw - rotation of the camera about the +Z axis, in degrees." << std::endl;
  std::cerr << "\tcamera_pitch - rotation of the camera about the +Y axis, in degrees." << std::endl;
  std::cerr << "\toutput - output file." << std::endl;
}


enum Range_Tool_Mode
{
  CPU = 0,
  OPEN_CL
};


struct Range_Args
{
  Range_Tool_Mode mode;
  std::string terrain;
  float fov;
  uint16_t dim;
  std::tuple<float, float, float> posn;
  float yaw;
  float pitch;
  std::string output;
};


Range_Args parse_range_tool_args(int argc, char ** argv)
{
  if (argc < 10) {
    std::cerr << "Invalid arguments. Expect at least 10 arguments" << std::endl;
    range_tool_usage();
    exit(EXIT_FAILURE);
  }

  Range_Args args;
  std::string modestr(argv[0]);
  if (modestr == "CPU") {
    args.mode = Range_Tool_Mode::CPU;
  } else if (modestr == "OpenCL") {
    args.mode = Range_Tool_Mode::OPEN_CL;
  } else {
    std::cerr << "Invalid mode. Only CPU and OpenCL are allowed" << std::endl;
    range_tool_usage();
    exit(EXIT_FAILURE);
  }

  args.terrain = std::string(argv[1]);
  args.fov = std::stof(argv[2]);
  args.dim = std::stoi(argv[3]);
  args.posn = std::make_tuple(std::stof(argv[4]), std::stof(argv[5]), std::stof(argv[6]));
  args.yaw = std::stof(argv[7]);
  args.pitch = std::stof(argv[8]);
  args.output = std::string(argv[9]);

  if (args.fov < 50 || args.fov > 180) {
    std::cerr << "Invalid Argument. Camera FOV must be in the range [50, 180]" << std::endl;
    range_tool_usage();
    exit(EXIT_FAILURE);
  }

  if (args.yaw < -360. || args.yaw > 360.) {
    std::cerr << "Invalid Argument. Camera Yaw must be in the range [-180, 180]" << std::endl;
    range_tool_usage();
    exit(EXIT_FAILURE);
  }

  if (args.pitch < -360. || args.pitch > 360.) {
    std::cerr << "Invalid Argument. Camera Pitch must be in the range [-180, 180]" << std::endl;
    range_tool_usage();
    exit(EXIT_FAILURE);
  }

  return args;
}


Terrain read_terrain_file(const std::string & fname)
{
  std::ifstream in(fname, std::ios::in | std::ios::binary);

  struct stat results;
  if (stat(fname.c_str(), &results)) {
    std::cerr << "Invalid argument, terrain file does not exist" << std::endl;
    range_tool_usage();
    exit(EXIT_FAILURE);
  }

  uint32_t file_size = results.st_size;

  uint32_t size;
  float scale;
  in.read(reinterpret_cast<char *>(&size), 4);

  if (file_size != (size * size * 4 + 8)) {
    std::cerr << "Invalid argument, file is not a terrain file (inconsistent size)" << std::endl;
    range_tool_usage();
    exit(EXIT_FAILURE);
  }

  in.read(reinterpret_cast<char *>(&scale), 4);

  auto b = std::make_shared<Buffer>(size, size);

  in.read(reinterpret_cast<char *>(b->data().get()), size * size * 4);
  
  return Terrain(b, scale);
}


void run_range_tool(int argc, char ** argv)
{
  // Parse args
  Range_Args args = parse_range_tool_args(argc, argv);

  // Set up terrain
  Terrain t = read_terrain_file(args.terrain);

  // Set up camera
  Camera cam(args.fov, args.dim, args.dim);
  cam.set_position(args.posn);
  cam.set_yaw(M_PI * args.yaw / 180.0);
  cam.set_pitch(M_PI * args.yaw / 180.0);

  // Set up calculator
  Range_Calculator * calculator;
  Terrain * tt;
  Buffer * rng;

  if (args.mode == Range_Tool_Mode::OPEN_CL)
  {
    std::shared_ptr<cl::Context> ctx = get_context();
    calculator = new CL_Range_Calculator(ctx);
    rng = new Device_Buffer(*ctx, args.dim, args.dim);

    // Transfer to a device buffer
    std::shared_ptr<Device_Buffer> tb = std::make_shared<Device_Buffer>(t.data(), *ctx);
    tt = new Terrain(tb, t.scale());
  } else {
    calculator = new CPU_Range_Calculator;
    rng = new Buffer(args.dim, args.dim);
    tt = &t;
  }

  std::cout << "Starting range mapping..." << std::endl;
  const auto start = std::chrono::high_resolution_clock::now();
  calculator->Calculate(cam, *tt, *rng);
  const auto end = std::chrono::high_resolution_clock::now();
  const auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
  std::cout << "Done. Completed in " << duration.count() << " us" << std::endl;

  std::ofstream out(args.output, std::ios::out | std::ios::binary);
  out.write(reinterpret_cast<char *>(&args.dim), 2); // dimension of image, 2 bytes (uint16_t)
  out.write(reinterpret_cast<char *>(rng->data().get()), args.dim * args.dim * 4);

  std::cout << "Wrote image to " << args.output << ". It can be viewed with CLarity viewer tool" << std::endl; 
}


void main(int argc, char ** argv)
{
  Tool t = get_tool_name(argc, argv);

  if (t == Tool::HELP) {
    Tool ht = get_tool_name(argc - 1, &(argv[1]));
    if (ht == Tool::RANGE_MAPPER) {
      range_tool_usage();
    } else if (ht == Tool::TERRAIN_GENERATOR) {
      terrain_tool_usage();
    } else {
      general_usage();
    }
  } else if (t == Tool::TERRAIN_GENERATOR) {
    run_terrain_tool(argc - 2, &(argv[2]));
  } else if (t == Tool::RANGE_MAPPER) {
    run_range_tool(argc - 2, &(argv[2]));
  }

  exit(EXIT_SUCCESS);
}

}}


int main(int argc, char ** argv)
{
  clarity::cli::main(argc, argv);

  return 0;
}

